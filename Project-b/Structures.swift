//
//  Structures.swift
//  Project-b
//
//  Created by Dylan Whitehurst on 3/19/21.
//

import Foundation

//MARK: Structures

//X: structures can consume from adjacent structures
//X: camp structure
//TODO: adjacency bonuses
//TODO: serializer

struct Farm: AnimatedStructure {
    let tickPriority: Int = 1
    internal var stage: Int = 0
    internal let maxStage: Int = 3
        
    var imageFile: String { [0: "farm-stage1", 1: "farm-stage2", 2: "farm-stage3", 3: "farm-stage4"][stage]! }
    
    internal let id = UUID()
    let name: String = "Farm"
    let price: Int = 1000
    let description: String = "Grows 1 corn every 4 seconds. Gains bonus corn for each surrounding water."
    let iconFile: String = "farm-stage4"
    
    var storageSlots = [StorageSlot(resourceType: .corn, quantity: 0, max: 1)]
    
    private let pos: MapPos // so that onTick has the key to this structure
    
    init (pos: MapPos) {
        self.pos = pos
    }
    
    func onPlace(model: inout GameModel) {
        model.subtractMoney(price)
    }
    
    func onTick(model: inout GameModel) {
        if storageSlots[0].quantity < storageSlots[0].max {
            var tempStage = stage //stage will not change with progressStage because structs are copy on write
            if tempStage < maxStage {
                model.structures[pos]!.progressStage()
                tempStage += 1
            }
            if tempStage == maxStage {
                model.structures[pos]!.storageSlots[0].add(1)
            }
        }
    }
    
    func onRemove(model: inout GameModel) {
        model.addMoney(price)
    }

}

struct StarterVillage: AnimatedStructure {

    //TODO: add animation to fire smoke
    let tickPriority: Int = 0
    internal var stage: Int = 0
    internal let maxStage: Int = 0
    
    internal let imageFile = "starter-village"
    
    internal let id = UUID()
    let name: String = "Village"
    let price: Int = 10000
    let description: String = "Your central settlement. Resources generated by adjacent structures will automatically be collected and added to your stock"
    let iconFile: String = "starter-village"
    
    var storageSlots = [StorageSlot(resourceType: .corn, quantity: 0, max: 1)]
    
    private let pos: MapPos // so that onTick has the key to this structure
    
    var indicators = [(ResourceType, Int)]()
    
    init (pos: MapPos) {
        self.pos = pos
    }
    
    func onPlace(model: inout GameModel) {
        model.subtractMoney(price)
    }
    
    func onTick(model: inout GameModel) {
        var total = 0
        for p in pos.adjacent() {
            if let quantity = model.structures[p]?.collectAllOf(type: .corn){
                if quantity > 0 {
                    model.addResource(.corn, quantity)
                    total += quantity
                }
            }
        }
        if total > 0 {
            model.structures[pos]?.indicators.append((.corn, total));
        }
        // TODO: collection speed upgrade?
        // for each adjacent structure, collect its maximum storage capacity
    }
    
    func onRemove(model: inout GameModel) {
        model.addMoney(price)
    }

}

//MARK: Internals

struct StorageSlot {
    let resourceType: ResourceType
    var quantity: Int
    //TODO: upgradable max storage?
    var max: Int
    
    mutating func add(_ quantity: Int) {
        if self.quantity < self.max {
            self.quantity += quantity
        } else {
            self.quantity = self.max
        }
    }
    
    //TODO: mutating func deposit (returns amount deposited)
    
    mutating func collectAll() -> Int {
        let temp = quantity
        self.quantity = 0
        return temp
    }
}

protocol BasicStructure: Watchable {
    var id: UUID { get }
    var name: String { get }
    var imageFile: String { get }
    
    var storageSlots: [StorageSlot] { get set }
    
    func onPlace (model: inout GameModel) -> Void
    func onTick (model: inout GameModel) -> Void
    func onRemove (model: inout GameModel) -> Void
    
}

protocol AnimatedStructure: BasicStructure {
    var price: Int { get }
    var tickPriority: Int { get }
    var indicators: [(ResourceType, Int)] { get set }
    var stage: Int { get set }
    var maxStage: Int { get }
    mutating func collectAllOf(type: ResourceType) -> Int
    mutating func progressStage() -> Void
}

extension AnimatedStructure {
    var indicators: [(ResourceType, Int)] {
        get {
            return [(ResourceType, Int)]()
        } set {
            
        }
    }
    
    mutating func progressStage() {
        if stage < maxStage {
            self.stage += 1
        } else {
            self.stage = 0
        }
    }
    
    mutating func collectAllOf(type: ResourceType) -> Int {
        for i in 0..<storageSlots.count {
            //TODO: bad
            if storageSlots[i].resourceType == type {
                let quantity = storageSlots[i].collectAll()
                if quantity == storageSlots[i].max {
                    self.stage = 0
                }
                return quantity
            }
        }
        return 0
        
    }
}

enum StructureType: String {
    case StarterVillage = "Village"
    case Farm = "Farm"
}
