//
//  Structures.swift
//  Project-b
//
//  Created by Dylan Whitehurst on 3/19/21.
//

import Foundation

//MARK: Structures

//TODO: structures can consume from adjacent structures
//TODO: camp structure
//TODO: adjacency bonuses
//TODO: serializer

struct Farm: AnimatedStructure {
    internal var stage: Int = 0
    internal let maxStage: Int = 3
    
    internal let imageFiles = [
                0: "farm-stage1",
                1: "farm-stage2",
                2: "farm-stage3",
                3: "farm-stage4",
            ]
    
    internal let id = UUID()
    let name: String = "Farm"
    let description: String = "Grows 1 corn every 4 seconds. Gains bonus corn for each surrounding water."
    let iconFile: String = "farm-stage4"
    
    var storage = BasicInternalStorage(resourceType: .corn, quantity: 0, max: 1)
    
    private let pos: MapPos // so that onTick has the key to this structure
    
    init (pos: MapPos) {
        self.pos = pos
    }
    
    func onPlace(model: inout GameModel) {
        model.subtractMoney(1000)
    }
    
    func onTick(model: inout GameModel) {
        if storage.quantity < storage.max {
            var tempStage = stage //stage will not change with progressStage because structs are copy on write
            if tempStage < maxStage {
                model.structures[pos]!.progressStage()
                tempStage += 1
            }
            if tempStage == maxStage {
                model.structures[pos]!.storage.add(1)
            }
        }
    }
    
    func onRemove(model: inout GameModel) {
        model.addMoney(1000)
    }

}

struct StarterVillage: AnimatedStructure {
    //TODO: add animation to fire smoke
    internal var stage: Int = 0
    internal let maxStage: Int = 0
    
    internal let imageFiles = [
                0: "starter-village"
            ]
    
    internal let id = UUID()
    let name: String = "Village"
    let description: String = "Your central settlement. Resources generated by adjacent structures will automatically be collected by villagers and added to your stock"
    let iconFile: String = "starter-village"
    
    //TODO: change to storage slots array
    var storage = BasicInternalStorage(resourceType: .corn, quantity: 0, max: 1)
    
    private let pos: MapPos // so that onTick has the key to this structure
    
    init (pos: MapPos) {
        self.pos = pos
    }
    
    func onPlace(model: inout GameModel) {}
    
    func onTick(model: inout GameModel) {
        // adjStrucs = getAdjacentStructures(to: pos)
        // TODO: collection speed upgrade?
        // for each structure, collect its maximum storage capacity
        if storage.quantity < storage.max {
            var tempStage = stage //stage will not change with progressStage because structs are copy on write
            if tempStage < maxStage {
                model.structures[pos]!.progressStage()
                tempStage += 1
            }
            if tempStage == maxStage {
                model.structures[pos]!.storage.add(1)
            }
        }
    }
    
    func onRemove(model: inout GameModel) {}

}

//MARK: Internals

struct BasicInternalStorage {
    let resourceType: ResourceType
    var quantity: Int
    //TODO: upgradable max storage?
    var max: Int
    
    mutating func add(_ quantity: Int) {
        if self.quantity < self.max {
            self.quantity += quantity
        } else {
            self.quantity = self.max
        }
    }
    
    //TODO: mutating func deposit (returns amount deposited)
    
    mutating func collectAll() -> Int {
        let temp = quantity
        self.quantity = 0
        return temp
    }
}

protocol BasicStructure: Watchable {
    var id: UUID { get }
    var name: String { get }
    var imageFile: String { get }
    
    var storage: BasicInternalStorage { get set }
    
    func onPlace (model: inout GameModel) -> Void
    func onTick (model: inout GameModel) -> Void
    func onRemove (model: inout GameModel) -> Void
}

protocol AnimatedStructure: BasicStructure {
    var stage: Int { get set }
    var maxStage: Int { get }
    var imageFiles: [Int: String] { get }
    mutating func collectAll() -> Int
    mutating func progressStage() -> Void
}

extension AnimatedStructure {
    mutating func progressStage() {
        if stage < maxStage {
            self.stage += 1
        } else {
            self.stage = 0
        }
    }
    
    mutating func collectAll() -> Int {
        let quantity = storage.collectAll()
        if quantity == storage.max {
            self.stage = 0
        }
        return quantity
        
    }
    
    var imageFile: String { return imageFiles[stage]! }
}


